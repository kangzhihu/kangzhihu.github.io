---
layout: post
title: "基础-HashMap"
subtitle: 'HashMapd概括与总结'
author: "Kang"
date: 2019-09-10 18:10:47
header-img: "img/post-head-img/stingray-4392776_960_720.jpg"
catalog: true
tags:
  - Java基础
---
## HashMap的快失败(非并发)
&emsp;&emsp;HashMap中存在modCount表示一个集合被修改的次数，使用expectedModCount在创建iterator时被赋值为modCount，每次有修改时加一。    
&emsp;&emsp;在使用集合的操作remove、put方法操作数据时只会修改modCount，但是迭代器在变更数据时会变更modCount和同步更新expectedModCount。这样若同时存在集合变更和迭代器变更，在迭代器next方法中，则modCount!=expectedModCount就会抛出fast-fail异常。

## HashMap非线程安全原因
1. hash碰撞插入：在并发put的情况下，两个线程都插入同一个hash值得数据，即发生hash碰撞，假如线程A刚好通过线性/树查找到自己的前驱节点后被切换到B，这样B也查找到了相同的位置，并完成了数据的存储，线程A被调度恢复后，仍在在原来的节点进行数据的插入，这样会导致B刚插入的数据丢失。
2. resize死循环获取：HashMap的get操作可能因为resize而引起死循环（cpu100%）。线程1在resize时，刚好检查到新的结构中节点A和B是前驱与后继关系时挂起，线程2完成resize动作，恰巧反过来B和A构成了前驱和后继关系(B.next=A)，此时线程1使用自己检测到的关系(A.next=B)，则会构成一个环。当使用get获取的时候，将出现死循环问题。
  
