---
layout: post
title: "事务隔离级别、锁与日志操作"
subtitle: '只想说的通俗易懂'
author: "Kang"
date: 2019-09-15 01:23:20
header-img: "img/post-head-img/herbal-3504948_1280.jpg"
catalog: true
tags:
  - 数据库
  - 事务
---
一个重要理解前提
1. 数据库的锁是加在数据行所在的索引上的。不同的隔离级别是在数据可靠性和并发性之间的均衡取舍，隔离级别越高，对应的并发性能越差，数据越安全可靠。  
2. RR与RC所存在锁的区别：<font color="red">RC不存在GAP间隙锁，而RR中存在。同样可知RC少了Next-key lock。</font>  
3. 每一个隔离级别都是对上一个隔离级别一个问题点的处理。     

> 还是没理解的点：对于同一条数据，在RR下是怎么防止快照读下变更覆盖的??  -- 在提交阶段检测DB_TRX_ID版本号or业务自己控制版本号？？

## 事务的隔离级别
- 未提交读(Read_Uncommit) 
&emsp;&emsp;B使用查询语句可能会读到A未提交的行（脏读）

- 提交读(Read_Commit,Oracle默认级别)  
  &emsp;&emsp;<font color="red">在读取记录时会加锁，一旦语句读取完毕，锁将自动被释放，不等整个事务结束，所以同一事务中先后两次读可能读取到的不一样。</font>      
  &emsp;&emsp;(解决读未提交,存在不可重复读<font color="green">[优化：通过整个事务加锁]</font>和幻读)

- 可重复读(Repeatable_Read,Mysql默认级别)    
&emsp;&emsp;<font color="red">在当前事务提交之前，其他任何事务均不可以修改或删除当前事务已读取的数据。只有当整个事务完成后，记录锁才会被释放，所以在同一个事务中，多次读取同一条数据肯定是相同的，但是对于其他事务插入的数据没法管理，所以对于新增数据，没有办法管理，会出现幻读。</font>      
&emsp;&emsp;(解决不可重复读[同一条数据读]，但是还是存在幻读<font color="green">[优化：通过GAP间隙锁进行减轻]</font>)  

- 串行化：  
&emsp;&emsp;事务操作加锁，构成操作队列。(解决不可重复读与幻读)

## InnoDB几种锁
#### 总览
- Record Lock：单个行记录上的锁，我们通常讲的行锁，<font color="red">它的实质是通过对索引的加锁实现</font>；只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。在事务隔离级别为读已提交下，仅采用Record Lock。   
- Gap Lock：间隙锁，锁定一个间隙范围，但不包含记录本身；    
- Next-Key Lock：Record Lock+Gap Lock，锁定一个范围，并且锁定记录本身。     
- 意向锁：意向锁不需要用户关心，每次事务A做行级锁等的时候，会在全局设置一个意向锁，当另一个事务B<font color="red">需要全局锁做操作时</font>，不需要事务B去做每一行数据的锁检查，而只需要看全局意向锁就行，所以意向锁和全局锁阻塞。意向锁与意向锁之间不阻塞；
- 表锁：操作对象是数据表。Mysql大多数锁策略都支持(常见mysql innodb)，是系统开销最低但并发性最低的一个锁策略。事务t对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务增删改都不行。通过添加表锁，达到部分情况下的快阻塞。  

####  临界锁 next-key
&emsp;&emsp;后面MVCC分析可知，可重复读和提交读是矛盾的。在同一个事务里，如果保证了可重复读，就会看不到其他事务的提交读取的总是快照旧数据，违背了提交读；如果保证了提交读，就会导致前后两次读到的结果不一致，违背了可重复读。    
&emsp;&emsp;为<font color="blue">左开右闭</font>，左间隙与行锁组合起来用就叫做Next-Key Lock，间隙锁主要创建在联合索引或者主键索引中，其是将查找到的主键前后节点之间的插入关闭。  

####  GAP间隙锁
&emsp;&emsp;范围查询或者等值查询时，若记录不存在则退化为GAP锁；

![mysql-Next-Key Lock示例1](https://raw.githubusercontent.com/kangzhihu/images/master/mysql-%E9%97%B4%E9%9A%99%E9%94%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

````sql
-- session 1:
start  transaction;
select * from news where number>4 for update;

-- session 2:
start  transaction;
update news set id=2 where number=4 ;#(执行成功)
update news set id=4 where number=4 ;#(阻塞)
update news set id=5 where number=5 ;#(阻塞)
insert into news value(2,3);#(执行成功)
insert into news value(null,13);#(阻塞)
````

```sql
-- session 1:
start  transaction;
select * from news where id>16 for update;#(间隙锁为13->无穷大)

-- session 2:
start  transaction;
insert into news value(14,3);#(阻塞)
```

&emsp;&emsp;检索条件number>4,向左取得最靠近的值4作为左区间，向右取无穷大，因此，session
1的间隙锁的范围（4，无穷大）。   
&emsp;&emsp;如果检索条件number>=4，那么，第一个id=4&number=4也会被阻塞。
     
&emsp;&emsp;next-key间隙锁其实包含了记录锁和间隙锁，即锁定一个范围，并且锁定记录本身防止其他事务的修改，从而防止幻读出现，InnoDB默认加锁方式是next-key锁。<font color="red">在RR级别下，通过next-key锁消除了不可重复读问题，并解决了部分情况下幻读的问题</font>

#### 意向锁
&emsp;&emsp;意向锁包括共享意向锁(读锁)&排它意向锁(写锁)
&emsp;&emsp;排它意向锁是一种Gap锁，不是意向锁，在insert操作时产生。    
&emsp;&emsp;insert在做插入时，其加锁过程为先在插入间隙上获取插入意向锁，插入数据后再获取插入行上的排它锁。插入意向锁与gap lock和 Next-key lock冲突的，需要等待这两种锁释放。
   
#### 锁的兼容性表    
![锁兼容矩阵](https://raw.githubusercontent.com/kangzhihu/images/master/mysql-%E9%94%81%E5%85%BC%E5%AE%B9%E8%A1%A8.jpg)  
&emsp;&emsp;可以看出插入意向锁(GAP)和gap lock和 Next-key lock是冲突的，需要阻塞等待。注意：RC比RR少了GAP锁和Next-key lock。  

[一个死锁参考](https://my.oschina.net/hebaodan/blog/1835966)


## MVCC
&emsp;&emsp;Multi-Version Concurrency Control 多版本并发控制。MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑使用了MVCC机制。MVCC是行级锁的一个变种，其实现没有标准，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。  
&emsp;&emsp;MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，当前事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。    
&emsp;&emsp;MVCC只在Repeatable-Read和Read-Commit两个隔离级别下工作。      

### MVCC的两种读
<font color="blue">MVCC是对行级锁的一种变种优化，个人理解可以认为是一种读写分离锁，</font>只不过是通过其它方式实现的。
#### 快照读(读锁)
&emsp;&emsp;读取的是快照版本，也就是历史版本。InnoDB默认普通的SELECT就是快照读。<font color="red">产生的快照是发生select的瞬间，而不是开启事务的时候。</font>
```sql
select * from table where ?;
```
#### 当前读(写锁)
&emsp;&emsp;读取的是最新版本,并在读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁，注意不是写锁，排它锁其它事务也不能读)。UPDATE、DELETE、INSERT、SELECT …  LOCK IN SHARE MODE、SELECT … FOR UPDATE是当前读。<font color="red">InnoDB默认涉及到数据变更操作和手动SELECT就是快照读。</font>      
```sql
select * from table where ? lock in share mode;
select * from table where ? for update;
insert into table values (…);
update table set ? where ?;
delete from table where ?;
```
&emsp;&emsp;用户一个update语句发送给Mysql Server后涉及到两步操作：  
1. Mysql Server将更新时携带条件的where进行提取，将提取语句投递给InnoDB引擎，InnoDB将返回符合条件的第一条数据，并将当前数据加排它锁(X锁)；--当前读。  
2. MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。  
3. 一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。  

[阅读-where 提取参考](http://hedengcheng.com/?p=577)

##### 对于当前读的锁操作    
[阅读-加锁参考](http://hedengcheng.com/?p=771)    
- 在RC级别中，若where存在主键可以直接定位，则将主键直接加X排它锁；若为组合索引，则先将组合索引中所有符合条件的索引加X锁，然后再将主键索引中全部加排他锁；若无任何索引，则将会引发所有索引添加X锁；
- 在RR级别中，若where存在主键可以直接定位，则将主键直接加X排它锁；若为组合索引，则先将组合索引中所有符合条件的索引加X锁，然后<font color="blue">将组合索引的间隙加锁(GAP锁)，最后再将对应的主键索引全部加排他锁；若无任何索引，则将会引发所有索引添加X锁并将间隙加GAP锁；</font>-- 二级索引都是加GAP锁而不是X锁       
![RR组合索引下查询加锁情况](https://raw.githubusercontent.com/kangzhihu/images/master/mysql-RR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E6%89%BE%E9%94%81%E6%83%85%E5%86%B5%E7%A4%BA%E4%BE%8B.jpg)    
&emsp;&emsp;上图为RR级别下的示例，(id,name)为一个组合索引。在RC级别下类似，只是少了GAP锁。     

###  InnoDB的MVCC版本处理  
&emsp;&emsp;innodb MVCC主要是为Repeatable-Read事务隔离级别做的。在此隔离级别下，A、B客户端所示的数据相互隔离，互相更新不可见。  
&emsp;&emsp;每一个业务字段中存在隐藏的几个字段(字段具体顺序不关注)：    
> DELETE_BIT|DB_TRX_ID|DB_ROLL_PTR|DB_ROW_ID     
> 删除位标识(1-已删除，0-未删除)|事务版本id|回滚指针(指向undo log)|行ID(可以认为是PK)   
 
+ 6字节的DATA_TRX_ID 用来标识最近一次对本行记录做修改(insert\|update)的事务的标识符, 即最后一次修改(insert\|update)本行记录的事务id。至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted, 并非真正删除。
+ 7字节的DATA_ROLL_PTR 指向当前记录项的rollback segment的undo log记录，被更新之前内容就是通过这个指针
+ 6字节的DB_ROW_ID，当由innodb自动产生聚集索引时，聚集索引包括这个DB_ROW_ID的值，否则聚集索引中不包括这个值.，这个用于索引当中
+ DELETE BIT位用于标识该记录是否被删除，这里的不是真正的删除数据，而是标志出来的删除。真正意义的删除是在commit的时候  
 

![mysql-MVCC在底层行中的结构](https://raw.githubusercontent.com/kangzhihu/images/master/mysql-MVCC%E8%AE%B0%E5%BD%95%E8%A1%8C%E4%B8%AD%E7%BB%93%E6%9E%84.png)  
具体的执行过程：<font color="blue">begin事务->用排他锁锁定该行->记录redo log->记录undo log->修改当前行的值，写事务编号(DATA_TRX_ID)，回滚指针指向undo log中的修改前的行</font>。上述过程确切地说是描述了UPDATE的事务过程，其实undo log分insert和update undo log，因为insert时，原始的数据并不存在，所以回滚时把insert undo log丢弃即可，而update undo log则必须遵守上述过程。

&emsp;&emsp;为了实现支持，在行中隐藏了两列字段：事务开始版本(startTransactionId)、事务结束版本(endTransactionId)，全局存在一个系统版本号(sysTransactionId)。 

#### DATA_ROLL_PTR中undo log的链表处理
&emsp;&emsp;每当开始一个事务时，当前事务版本号从innodb事务系统申请，并且按照申请顺序严格递增，即currentTransactionId=sysTransactionId  
- 查询：只是读，InnoDB只查找版本早于当前事务版本的数据行(也就是数据行的版本必须小于等于事务的版本)，这确保当前事务读取的行都是事务之前已经提交的可用数据，或者是由当前事务创建或修改的行。 --读取事务创建时/之前的可用数据(可能读取时之前的事务有做提交，所以需要查询到最近提交的那个记录)，为了阻断其他事务的修改，所以使用For Update 添加X锁。  
- 插入：DATA_TRX_ID = currentTransactionId。
- 更新：在更新时InnoDB会复制一行数据(最近已提交数据)。这个新行的版本号使用了系统版本号。它也把系统版本号作为了删除行的版本。
- 删除：也是与更新一样的操作，但是设置了DELETE BIT标志位，若没有commit则只是打上了标识，未真实删除。

####  MVCC示例解析
[推荐阅读-Mysql中的MVCC](https://blog.csdn.net/chen77716/article/details/6742128)
&emsp;&emsp;在实现上，innodb为每个事务构建一个数组，用来保存这个事务启动瞬间，当前正在活跃的所有事务ID （活跃指的是启动了但还未提交）数组里面ID最小值称之为 低水位，最大值加1称之为 高水位，视图数组和高水位组成了当前事务的一致性视图（read-view）    
&emsp;&emsp;一个数据版本，对于一个事务视图来说，除了自己的更新总是可见外，有三种情况：
1. 版本未提交，不可见
2. 版本已提交，但是是在视图创建后提交的，不可见
3. 版本已提交，并且是在视图创建前提交的，可见   

&emsp;&emsp;一个mysql-MVCC可重复读示例如下，在开始事务操作时，存在数据(1,1)，存在活跃事务为90，事务A,B,C的版本号分别为100,101,102：   
![mysql-MVCC事务流程示例](https://raw.githubusercontent.com/kangzhihu/images/master/mysql-MVCC%E4%BA%8B%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%9B%BE.png)
&emsp;&emsp;start transaction with consistent snapshot 表示马上开启一个事务，mysql 默认 autocommit = 1；   
问题来了：事务A，B，C查询的结果分别为多少？  
根据可重复读的隔离级别：事务A的查询结果为1，事务B的查询结果为3  
a. 事务A开始前，系统只存在一个活跃事务ID 是99  
b. 事务A,B,C的版本号分别为100,101,102，且当前系统只存在这4个事务  
c. 三个事务开始前，数据(1,1)的DATA_TRX_ID 为 90   

&emsp;&emsp;根据事务对记录的操作时间点的先后顺序，构成下面的一个undo log事务操作链表：  
![mysql-MVCC可重复读示例](https://raw.githubusercontent.com/kangzhihu/images/master/mysql-MVCC%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%A4%BA%E4%BE%8B.png)   
d.数据(1,1)最早版本为 (90,1,1)  
e.事务C首先更新，版本变为 (102,1,2)  
f.事务B再次更新，版本变为 (101,1,3)  
g.因此事务A [99,100]查询数据时候，由于101,102对它不可见，所以事务A查询结果为1，又由于<font color="red">update为当前读</font>(使用时读取，另外两个已经提交)，所以事务B查询结果为3(前提是C已经提交数据可见)。    

&emsp;&emsp;**<font color="red">mysql中默认事务隔离级别是RR，在此隔离级别中的一个事务，MVCC所有的普通读是当前快照中的数据--快照读。通过MVCC锁消除了脏读问题，并且表现出来可重复读，但是存在较大的问题是数据只是当前时间点的最新版本，而不能始终保持最新。在RC级别下，就有不同，RC下每次SELECT时将重置read-view为最新的存活事务ID快照，所以读取数据为最新。</font>**      
&emsp;&emsp;为了安全性，其实还是要手动加锁才行：select name from student where id >= 0 for update。所以在事务中，第一句操作入口添加for update作为全局事务操作锁。  


-----

## 操作日志
#### redo log
redo log就是保存执行的SQL语句到一个指定的Log文件，当Mysql执行recovery时重新执行redo log记录的SQL操作（更新语句）即可。当客户端执行每条SQL时，redo log会被首先写入<font color="red">log buffer；当客户端执行COMMIT命令时，log buffer中的内容会被视情况刷新到磁盘</font>。redo log在磁盘上作为一个独立的文件存在，即Innodb的log文件。
#### undo log
与redo log相反，undo log是为回滚而用，具体内容就是copy事务前的数据库内容（行）到<font color="red">undo buffer，在适合的时间把undo buffer中的内容刷新到磁盘</font>。undo buffer与redo buffer一样，也是环形缓冲，但当缓冲满的时候，undo buffer中的内容会也会被刷新到磁盘；与redo log不同的是，磁盘上不存在单独的undo log文件，所有的undo log均存放在主ibd数据文件中（表空间），即使客户端设置了每表一个数据文件也是如此。

##### 操作日志过程 
&emsp;&emsp;一个事务的事务型操作过程归纳为下列步骤：  
1. 索引打标上排它锁(事务型操作)；
2. 将原数据入log buffer进行备份；
3. copy原数据到undo log文件中，方便事务进行构建回滚点；
4. 操作变更业务字段值，DB_TRX_ID，回滚指针到undo log中地址；
5. 在事务操作时，检测到存在排它锁，进入事务挂起等待阶段，等前面的事务提交后才继续执行。<font color="blue">RR下为了防止对同一条数据变更出现可重复读并发变更，需要再变更前使用select ... for update进行排它锁定 -- --> 一锁二查三变更</font>
6. 提交事务，log buffer刷入redo log文件中(或purge线程处理？)。

&emsp;&emsp;此处只通过RR隔离级别下的一个例子讲解undo日志怎么变更。   
```sql
create index test_idx on test(comment);
insert into test values(1, ‘aaa’);
insert into test values(2, ‘bbb’);

-- update primary key
update test set id = 9 where id = 1;   --- 语句1

-- update non-primary key with different value
update test set comment = ‘ccc’ where id = 9; --- 语句2

-- 初始时DB_TRX_ID事务id为1809，当前事务id为1811
```
[示例参考](http://hedengcheng.com/?p=148#_Toc322691905)

![数据主键变更undo示例](https://raw.githubusercontent.com/kangzhihu/images/master/mysql-undo%E5%88%A0%E9%99%A4%E7%A4%BA%E4%BE%8B.png)   
&emsp;&emsp;语句1处：主键的变更对InnoDB来说其实是删除原数据并插入一条新数据，所以在索引上加锁后，原数据删除标志位DELETE_BIT变更为0，并且回滚指针指向了undo log中记录的变更前的原始数据并变更事务版本号。同时，在索引上添加一条记录，该记录回滚指向为空。     
![数据变更undo示例](https://raw.githubusercontent.com/kangzhihu/images/master/mysql-undo%E5%8F%98%E6%9B%B4%E7%A4%BA%E4%BE%8B.png)    
&emsp;&emsp;语句2处：此阶段和前面没有什么不同，只是需要将二级索引进行重构，将comment='ccc'添加进去，同时，在undo long中，回滚的原始数据添加到回滚链中去。  
&emsp;&emsp;有一个点需要注意，<font color="red">undo log记录了所有事务操作数据的回滚点，同一条数据变更(即DB_ROW_ID相同)在同一个(链表)链路中</font>


preDo:   
&emsp;&emsp;将数据库事务commit提交4个阶段：  
1. 清理undo段信息：对于innodb存储引擎的更新操作来说，undo段需要purge，这里的purge主要职能是，真正删除物理记录。在执行delete或update操作时，实际旧记录没有真正删除，只是在记录上打了一个标记，而是在事务提交后，purge线程真正删除，释放物理页空间。因此，提交过程中会将undo信息加入purge列表，供purge线程处理。
2. 释放锁资源：mysql通过锁互斥机制保证不同事务不同时操作一条记录，事务执行后才会真正释放所有锁资源，并唤醒等待其锁资源的其他事务；
3. 刷redo日志：通过redo日志落盘操作，保证了即使修改的数据页即使没有更新到磁盘，只要日志是完成了，就能保证数据库的完整性和一致性；
4. 清理保存点列表：每个语句实际都会有一个savepoint(保存点)，保存点作用是为了可以回滚到事务的任何一个语句执行前的状态，由于事务都已经提交了，所以保存点列表可以被清理了。
