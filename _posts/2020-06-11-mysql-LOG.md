---
layout: post
title: "事务隔离级别-日志"
subtitle: '只想说的通俗易懂'
author: "Kang"
date: 2020-06-11 11:45:06
header-img: "img/post-head-img/herbal-3504948_1280.jpg"
catalog: true
tags:
  - 数据库
  - 事务
  - 日志
---
## 操作日志
#### redo log
&emsp;&emsp;redo log就是保存执行的SQL语句到一个指定的Log文件，当Mysql执行recovery时重新执行redo log记录的SQL操作（更新语句）即可。当客户端执行每条SQL时，redo log会被首先写入<font color="red">log buffer；当客户端执行COMMIT命令时，log buffer中的内容会被视情况刷新到磁盘</font>。redo log在磁盘上作为一个独立的文件存在，即Innodb的log文件。
#### undo log
与redo log相反，undo log是为回滚而用，具体内容就是copy事务前的数据库内容（行）到<font color="red">undo buffer，在适合的时间把undo buffer中的内容刷新到磁盘</font>。undo buffer与redo buffer一样，也是环形缓冲，但当缓冲满的时候，undo buffer中的内容会也会被刷新到磁盘；与redo log不同的是，磁盘上不存在单独的undo log文件，所有的undo log均存放在主ibd数据文件中（表空间），即使客户端设置了每表一个数据文件也是如此。

##### 操作日志过程 
&emsp;&emsp;一个事务的事务型操作过程归纳为下列步骤：  
1. 索引打标上排它锁(事务型操作)；
2. 将原数据入log buffer进行备份；
3. copy原数据到undo log文件中，方便事务进行构建回滚点；
4. 操作变更业务字段值，DB_TRX_ID，回滚指针到undo log中地址；
5. 在事务操作时，检测到存在排它锁，进入事务挂起等待阶段，等前面的事务提交后才继续执行。<font color="blue">RR下为了防止对同一条数据变更出现可重复读并发变更，需要再变更前使用select ... for update进行排它锁定 -- --> 一锁二查三变更</font>
6. 提交事务，log buffer刷入redo log文件中(或purge线程处理？)。

&emsp;&emsp;此处只通过RR隔离级别下的一个例子讲解undo日志怎么变更。   
```sql
create index test_idx on test(comment);
insert into test values(1, ‘aaa’);
insert into test values(2, ‘bbb’);

-- update primary key
update test set id = 9 where id = 1;   --- 语句1

-- update non-primary key with different value
update test set comment = ‘ccc’ where id = 9; --- 语句2

-- 初始时DB_TRX_ID事务id为1809，当前事务id为1811
```
[示例参考](http://hedengcheng.com/?p=148#_Toc322691905)

![数据主键变更undo示例](https://raw.githubusercontent.com/kangzhihu/images/master/mysql-undo%E5%88%A0%E9%99%A4%E7%A4%BA%E4%BE%8B.png)   
&emsp;&emsp;语句1处：主键的变更对InnoDB来说其实是删除原数据并插入一条新数据，所以在索引上加锁后，原数据删除标志位DELETE_BIT变更为0，并且回滚指针指向了undo log中记录的变更前的原始数据并变更事务版本号。同时，在索引上添加一条记录，该记录回滚指向为空。     
![数据变更undo示例](https://raw.githubusercontent.com/kangzhihu/images/master/mysql-undo%E5%8F%98%E6%9B%B4%E7%A4%BA%E4%BE%8B.png)    
&emsp;&emsp;语句2处：此阶段和前面没有什么不同，只是需要将二级索引进行重构，将comment='ccc'添加进去，同时，在undo long中，回滚的原始数据添加到回滚链中去。  
&emsp;&emsp;有一个点需要注意，<font color="red">undo log记录了所有事务操作数据的回滚点，同一条数据变更(即DB_ROW_ID相同)在同一个(链表)链路中</font>


preDo:   
&emsp;&emsp;将数据库事务commit提交4个阶段：  
1. 清理undo段信息：对于innodb存储引擎的更新操作来说，undo段需要purge，这里的purge主要职能是，真正删除物理记录。在执行delete或update操作时，实际旧记录没有真正删除，只是在记录上打了一个标记，而是在事务提交后，purge线程真正删除，释放物理页空间。因此，提交过程中会将undo信息加入purge列表，供purge线程处理。
2. 释放锁资源：mysql通过锁互斥机制保证不同事务不同时操作一条记录，事务执行后才会真正释放所有锁资源，并唤醒等待其锁资源的其他事务；
3. 刷redo日志：通过redo日志落盘操作，保证了即使修改的数据页即使没有更新到磁盘，只要日志是完成了，就能保证数据库的完整性和一致性；
4. 清理保存点列表：每个语句实际都会有一个savepoint(保存点)，保存点作用是为了可以回滚到事务的任何一个语句执行前的状态，由于事务都已经提交了，所以保存点列表可以被清理了。
