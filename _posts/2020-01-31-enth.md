---
layout: post
title: "区块链"
subtitle: '区块链'
author: "Kang"
date: 2020-1-23 12:40:45
header-img: "img/post-head-img/books.jpg"
catalog: true
tags:
  - 区块链

---
&emsp;&emsp;&emsp;&emsp;非对称加解密：

![解密与解密示意图](https://raw.githubusercontent.com/kangzhihu/images/master/非对称加密与解密示消息发送.png) 

&emsp;&emsp;存在私钥签名则证明是本人发出。

比特币中所有的交易都包含输入和输出两部分，输入部分需要存在签名(也就是私钥签名)，说明币的来源，输出部分要给出收款人的公钥的hash(也就是公钥加密)。



merkle proof：必须先给出需要验证节点的位置，然后返回该节点的Merkle路径。Merkle Proof包括一个数据块，Merkle Root，以及从数据块到根路径上的所有Hash组成的"分支"。



Double spending attack

&emsp;&emsp;所有用户共同维护区块链。比特币中存在两个指针，一个是区块链之前的指针，这个 指针构成了链并防止篡改；另外一个指针区块链中每一个交易记录存在一个指针，指向上一个交易记录，也即指向交易的输入来源，通过这个指针可以做交易的回溯、防捏造以及double spenging，在确认交易时，交易来源(输入)必须是UTXO中的。

&emsp;&emsp;Double spending是对同一个比特币同时进行了两次支付。双花存在两种，一种是打包结果稳定前，一种是稳定后，稳定前，由于交易的合法性验证，则可以防止，只确认一条交易。对于稳定后，为了产生双花，只能伪造交易并打包，这就必须产生分叉。 由于善意的节点会做区块合法性的校验，故善意的节点会沿着之前的节点进行，此时就存在了两个等长(长度1)的节点。为了保证伪造的分叉不被只能通过51%算力攻击来实现。



1. 比特币中如何获取转账目标地址?

&emsp;&emsp;通过收款人的公钥推算出来的收款人地址(取hash等转换)。

2. 转账时怎么知道金额足够？

&emsp;&emsp;交易头部输入部分验证。

3. A给B转账，怎么证明是A转出？

&emsp;&emsp;私钥签名。

3. A给B转账，如何公布A的公钥？

&emsp;&emsp;为了验证交易的合法性，所有的旷工需要获知A的公钥，且B也必须知道A的公钥以验证合法性。在交易的输入部分中，A自己将公钥写入交易head中，以方便全局使用。

5. 如何防止其他人员使用A的公钥伪造交易？

&emsp;&emsp;一个账号的所有交易起始于铸币交易(coinbase tx)。任意一笔交易确认后，其再次发起交易时，为了证明当前交易所使用币来源合法性，其输入部分会携带币的来源和账户的公钥，这个公钥也就是上一个交易的输出部分的目标地址公钥(合法情况下也就是发起方的账户地址)。假设一次交易中发起方A的公钥被篡改，那么在验证币的来源时，当前输入部分的公钥则与上一次交易输出部分的公钥匹配不上，交易合法性无法通过。···

```
一笔交易，head中包涵的输入和输出两部分：

输入部分(转出方的描述)：

   币的来源(前一条交易的地址)；

   A的公钥；

输出部分(接收方的描述)：

   B的公钥；
```

由于没有总账户的概念，所以必须说明币的来源，这样实现比较复杂，在以太坊中就存在账户概念。





6. 比特币一致性？

&emsp;&emsp;一般的分布式一致性，可以基于账户的数目投票的方式来实现，但是这种方式存在一个前提：参与投票者数量是固定的。在比特币中这种方式是不太现实的，因为比特币的账户产生无限制，且其它成员也不容易感知到账户的产生(当新账户不参与交互时)，所以容易产生Sybil attack(女巫攻击)。

&emsp;&emsp;比特币中使用算力投票的方式，谁先获取到nonce(POW工作量证明)，谁获取到记账权。



7. 如何解决分叉？

&emsp;&emsp;新的节点都是尝试添加到最长合法链上。当并发产生分叉时，区块链允许临时的存在分叉情况，直到其中某一个分叉胜出(长度相同时新的节点随机选择一个分叉？)，另一个分叉将被丢弃成为orphan block。

在以工作量证明机制为共识算法的区块链系统中，从分叉的区块起，由于不同的矿工跟从了不同的区块，在分叉出来的两条不同链上，算力是有差别的。形象地说，就是跟从两个链矿工的数量是不同的。由于解题能力和矿工的数量成正比，因此两条链的增长速度也是不一样的，在一段时间之后，总有一条链的长度要超过另一条。当矿工发现全网有一条更长的链时，他就会抛弃他当前的链，把新的更长的链全部复制回来，在这条链的基础上继续挖矿。

所有矿工都这样操作，这条链就成为了主链，分叉出来被抛弃掉的链就消失了。

-- 问题：感知不到分叉，如何保证不会被确认。

8. UTXO

&emsp;&emsp;UTXO：账户维度，维护在"全节点"中(包含全部交易数据)，每个全节点在内存中维护自己的UTXO数据。当UTXO中一条记录被消费时，该记录从“未使用”变更为“已使用”，并从UTXO中移除(<font color="red">交易确认后移除？？</font>)。

​	   重放攻击：由于网络等原因，使得相同的交易执行了多次被称为重放攻击。 由于每次使用时原UTXO记录均标记为已使用，故相同交易不会被使用两次。







9. 何时获取出块奖励？分叉的块怎么处理奖励？



当存在分叉时，当前块不会被确认，也给不出奖励。



10. 组装区块时如何证明交易记录的合法性？

余额证明，私钥签名，公钥加密。



11. 获取记账权的旷工能不能伪造变更交易；

&emsp;&emsp;当一个网络中存在少数恶意旷工时，假设恶意旷工获取了记账权，此时其对外发布打包的区块(其中包含伪造的交易)，对于其他善意的旷工来说，其将对每条交易记录进行验证，这种情况下验证不通过后会拒绝该块入链，任然沿着之前链路中验证过得区块继续挖矿。

&emsp;&emsp;其实对于恶意旷工来说，伪造交易的代价是很大的，当获取了记账权而因为交易验证不通过被拒绝时，不交浪费了算力，更是损失了打包奖励。



12. 出块时间过短的问题

&emsp;&emsp;当出块时间过短时，比特币网络传播存在延时，这样会导致当前块在网路中广播记账权时，可能其他未接受到信息的旷工仍然沿着之前的链路挖矿，并且也也挖到了矿，这样会导致分叉的出现。故出块时间越短，越容易分叉。当同一点分叉过多时，系统的总算力将被分散到各个叉链路中去，此时若有恶意的阶段集中算力扩展恶意的分叉，将很快将导致恶意分叉变为最长，最终导致攻击成功，故不是出块时间也短也好，若需要加快出块时间，则需要其它机制对分叉进行处理。



13. bitcoin如何保证安全性的？

    从两方面保证，密码学+共识机制。

- 密码学：私钥签名，公钥加密。前提是节点大部分是善意的。
- 共识机制：相同的认证机制。



14. 交易的脚本P2PK

当前交易的输入脚本 input script:

```shell
PUSHDATA(Sig) #私钥签名
```

上一个交易(交易来源)的输出脚本 output script:

```shell
PUSHDATA(pubKey) #收款人公钥
CHECKSIG #
```

私钥和公钥分别入栈弹出后后，执行CHECKSIG使用公钥检查签名。



